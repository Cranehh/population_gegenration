# 整数噪声添加方法修改指南

## 当前实现分析

当前的`DiffusionScheduler.add_noise`方法使用连续的高斯噪声：

```python
def add_noise(self, x_start, noise, timesteps):
    """添加噪声到原始数据"""
    sqrt_alphas_cumprod_t = self.sqrt_alphas_cumprod[timesteps].reshape(-1, 1)
    sqrt_one_minus_alphas_cumprod_t = self.sqrt_one_minus_alphas_cumprod[timesteps].reshape(-1, 1)
    
    # 对于成员数据，需要额外处理维度
    if len(x_start.shape) == 3:  # member data: [batch, family_size, features]
        sqrt_alphas_cumprod_t = sqrt_alphas_cumprod_t.unsqueeze(-1)
        sqrt_one_minus_alphas_cumprod_t = sqrt_one_minus_alphas_cumprod_t.unsqueeze(-1)
    
    return sqrt_alphas_cumprod_t * x_start + sqrt_one_minus_alphas_cumprod_t * noise
```

## 修改方案

为支持整数变量的噪声添加，需要区分连续变量和离散变量的处理方式：

### 1. 修改后的DiffusionScheduler类

```python
class DiffusionScheduler:
    """扩散调度器，支持整数噪声"""
    def __init__(self, num_timesteps=1000, beta_start=0.0001, beta_end=0.02):
        self.num_timesteps = num_timesteps
        
        # 创建beta调度
        self.betas = torch.linspace(beta_start, beta_end, num_timesteps)
        self.alphas = 1.0 - self.betas
        self.alphas_cumprod = torch.cumprod(self.alphas, dim=0)
        
        # 为采样准备的系数
        self.sqrt_alphas_cumprod = torch.sqrt(self.alphas_cumprod)
        self.sqrt_one_minus_alphas_cumprod = torch.sqrt(1.0 - self.alphas_cumprod)
        
    def add_noise(self, x_start, noise, timesteps, discrete_mask=None, noise_scale=1.0):
        """
        添加噪声到原始数据，支持整数和连续变量
        
        Args:
            x_start: 原始数据
            noise: 噪声张量
            timesteps: 时间步
            discrete_mask: 布尔掩码，标记哪些特征是离散的 [feature_dim] 或 None
            noise_scale: 整数噪声的强度系数
        """
        sqrt_alphas_cumprod_t = self.sqrt_alphas_cumprod[timesteps].reshape(-1, 1)
        sqrt_one_minus_alphas_cumprod_t = self.sqrt_one_minus_alphas_cumprod[timesteps].reshape(-1, 1)
        
        # 对于成员数据，需要额外处理维度
        if len(x_start.shape) == 3:  # member data: [batch, family_size, features]
            sqrt_alphas_cumprod_t = sqrt_alphas_cumprod_t.unsqueeze(-1)
            sqrt_one_minus_alphas_cumprod_t = sqrt_one_minus_alphas_cumprod_t.unsqueeze(-1)
        
        # 标准连续噪声添加
        noisy_data = sqrt_alphas_cumprod_t * x_start + sqrt_one_minus_alphas_cumprod_t * noise
        
        # 如果指定了离散掩码，对整数变量进行特殊处理
        if discrete_mask is not None:
            # 确保discrete_mask的维度匹配
            if len(x_start.shape) == 3:  # member data
                discrete_mask = discrete_mask.unsqueeze(0).unsqueeze(0)  # [1, 1, features]
            elif len(x_start.shape) == 2:  # family data
                discrete_mask = discrete_mask.unsqueeze(0)  # [1, features]
            
            # 生成整数噪声（泊松分布或均匀分布）
            discrete_noise = self.generate_discrete_noise(
                x_start, timesteps, discrete_mask, noise_scale
            )
            
            # 对离散特征使用整数噪声，连续特征保持原有处理
            noisy_data = torch.where(
                discrete_mask,
                x_start + discrete_noise,  # 整数变量：原值 + 整数噪声
                noisy_data  # 连续变量：标准扩散噪声
            )
            
            # 确保整数变量仍为整数
            noisy_data = torch.where(
                discrete_mask,
                torch.round(noisy_data),  # 四舍五入到最近整数
                noisy_data
            )
        
        return noisy_data
    
    def generate_discrete_noise(self, x_start, timesteps, discrete_mask, noise_scale):
        """
        生成整数噪声
        
        Args:
            x_start: 原始数据
            timesteps: 时间步
            discrete_mask: 离散变量掩码
            noise_scale: 噪声强度
        """
        # 根据时间步调整噪声强度
        t_normalized = timesteps.float() / self.num_timesteps  # [0, 1]
        if len(x_start.shape) == 3:  # member data
            t_normalized = t_normalized.reshape(-1, 1, 1)
        else:  # family data
            t_normalized = t_normalized.reshape(-1, 1)
        
        # 泊松噪声：lambda随时间步增加
        lambda_param = noise_scale * t_normalized * 3.0  # 最大lambda=3
        
        # 生成泊松分布的正负噪声
        poisson_noise = torch.poisson(lambda_param)
        
        # 随机符号（50%概率为正，50%为负）
        sign = torch.randint_like(poisson_noise, 0, 2) * 2 - 1  # {-1, 1}
        discrete_noise = poisson_noise * sign
        
        # 只在离散位置应用噪声
        discrete_noise = torch.where(discrete_mask, discrete_noise, torch.zeros_like(discrete_noise))
        
        return discrete_noise
    
    def to(self, device):
        """移动到指定设备"""
        self.sqrt_alphas_cumprod = self.sqrt_alphas_cumprod.to(device)
        self.sqrt_one_minus_alphas_cumprod = self.sqrt_one_minus_alphas_cumprod.to(device)
        return self
```

### 2. 在训练循环中的使用

修改train.py中的训练循环：

```python
# 在main函数开始处定义离散变量掩码
def create_discrete_masks():
    """定义哪些特征是离散的"""
    # 家庭特征掩码 (假设有8个家庭特征)
    family_discrete_mask = torch.tensor([
        False,  # 连续特征1
        False,  # 连续特征2
        True,   # 家庭人数 (整数)
        True,   # 学生人数 (整数)
        False,  # 收入 (连续)
        True,   # 某个类别变量 (整数)
        False,  # 其他连续特征
        False   # 其他连续特征
    ])
    
    # 个人特征掩码 (假设有10个个人特征)
    member_discrete_mask = torch.tensor([
        True,   # 年龄 (整数)
        True,   # 性别 (0/1)
        True,   # 驾照 (0/1)
        True,   # 关系类型 (整数类别)
        True,   # 教育水平 (整数等级)
        True,   # 职业类型 (整数类别)
        False,  # 某个连续特征
        False,  # 某个连续特征
        False,  # 某个连续特征
        False   # 某个连续特征
    ])
    
    return family_discrete_mask, member_discrete_mask

# 在训练循环中
for batch in progress_bar:
    # ... 数据准备代码 ...
    
    # 获取离散掩码
    family_discrete_mask, member_discrete_mask = create_discrete_masks()
    family_discrete_mask = family_discrete_mask.to(device)
    member_discrete_mask = member_discrete_mask.to(device)
    
    # 创建噪声
    noise_family = torch.randn_like(family_data)
    noise_member = torch.randn_like(member_data)
    
    # 添加噪声（支持整数噪声）
    x_family_noisy = scheduler.add_noise(
        family_data, noise_family, t, 
        discrete_mask=family_discrete_mask, 
        noise_scale=1.0
    )
    x_member_noisy = scheduler.add_noise(
        member_data, noise_member, t_person, 
        discrete_mask=member_discrete_mask, 
        noise_scale=1.0
    )
    
    # ... 其余训练代码保持不变 ...
```

### 3. 替代噪声策略

如果泊松噪声不适合，可以使用以下替代方案：

#### 方案A: 均匀整数噪声
```python
def generate_uniform_discrete_noise(self, x_start, timesteps, discrete_mask, noise_scale):
    """生成均匀分布的整数噪声"""
    t_normalized = timesteps.float() / self.num_timesteps
    if len(x_start.shape) == 3:
        t_normalized = t_normalized.reshape(-1, 1, 1)
    else:
        t_normalized = t_normalized.reshape(-1, 1)
    
    # 最大噪声范围随时间步增加
    max_noise = noise_scale * t_normalized * 5  # 最大±5
    
    # 生成均匀分布的整数噪声
    noise_range = torch.ceil(max_noise).int()
    discrete_noise = torch.randint_like(
        x_start.int(), 
        -noise_range, 
        noise_range + 1
    ).float()
    
    return torch.where(discrete_mask, discrete_noise, torch.zeros_like(discrete_noise))
```

#### 方案B: 基于原值的相对噪声
```python
def generate_relative_discrete_noise(self, x_start, timesteps, discrete_mask, noise_scale):
    """基于原值大小的相对整数噪声"""
    t_normalized = timesteps.float() / self.num_timesteps
    if len(x_start.shape) == 3:
        t_normalized = t_normalized.reshape(-1, 1, 1)
    else:
        t_normalized = t_normalized.reshape(-1, 1)
    
    # 基于原值的相对噪声强度
    relative_noise_strength = noise_scale * t_normalized * 0.3  # 最大30%噪声
    max_noise = torch.ceil(torch.abs(x_start) * relative_noise_strength + 1).int()
    
    # 生成相对噪声
    sign = torch.randint_like(x_start.int(), 0, 2) * 2 - 1
    discrete_noise = torch.randint_like(x_start.int(), 0, max_noise + 1).float() * sign.float()
    
    return torch.where(discrete_mask, discrete_noise, torch.zeros_like(discrete_noise))
```

## 使用建议

1. **噪声强度调节**: 根据不同整数变量的取值范围调整`noise_scale`
2. **掩码定义**: 仔细定义每个特征是否为离散变量
3. **边界处理**: 对有界的整数变量（如0-1二元变量）添加边界约束
4. **验证效果**: 在生成样本时检查整数变量是否保持了合理的分布

## 注意事项

- 整数噪声会改变原始的扩散过程理论基础
- 需要相应调整损失函数来处理离散变量
- 可能需要调整采样过程以确保生成的整数变量合理